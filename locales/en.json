{
    "title": "Maximilien Nadji - Linux System Administrator",
    "appointment": "Appointment",
    "about": "About",
    "index": {
        "title": "Introduction",
        "presentation": "<p>My name is Maximilien Nadji, and I am a freelance Linux System Administrator embracing the DevOps philosophy.<br>I maintain a <a href=\"/blog\">blog</a> containing articles on freelancing, Linux, and DevOps, where I share insights.</p>",
        "services": "<ul class=\"services-list\"><li class=\"service\"><strong>User & Group Management:</strong> Create, configure, and manage local user accounts, group permissions, resource limits, and ACLs.</li><li class=\"service\"><strong>Job Scheduling & Automation:</strong> Manage and schedule recurring tasks and command executions.</li><li class=\"service\"><strong>Disk & Storage Management:</strong> Configure and manage disk partitions, LVM storage, swap space, filesystems, and automounting.</li><li class=\"service\"><strong>System Recovery:</strong> Efficiently recover from hardware, OS, or filesystem failures.</li><li class=\"service\"><strong>Network Configuration:</strong> Set up packet filtering, IPv4/IPv6 networking, port redirection, NAT, static/dynamic routing, and SSH access.</li><li class=\"service\"><strong>Security & Compliance Audits:</strong> Assess system security, performance, and compliance through detailed audits.</li><li class=\"service\"><strong>Reverse Proxy & Load Balancing:</strong> Implement and configure reverse proxies and load balancers (Nginx, Traefik).</li><li class=\"service\"><strong>Software Deployment & Management:</strong> Deploy, configure, and maintain software installations, updates, and core services.</li><li class=\"service\"><strong>Containerization & Orchestration:</strong> Configure Docker/Podman, manage Kubernetes clusters, and orchestrate container deployments.</li><li class=\"service\"><strong>CI/CD Automation:</strong> Automate application deployment pipelines using continuous integration and delivery tools.</li><li class=\"service\"><strong>Performance Monitoring:</strong> Real-time monitoring of system performance with tools like Prometheus and Grafana.</li></ul>",
        "contact": "<h2>Interested in discussing your needs?</h2>Schedule <a class=\"contact\" href=\"https://calendly.com/maximiliennadji/30min\"> an appointment directly <\/a> or <a class=\"contact\" href=\"https://www.linkedin.com/in/maximilien-nadji/\"> contact me on LinkedIn <\/a> to discuss further."
    },
    "about_page": {
        "title": "More about me",
        "content": "<p>My first steps in computing were in middle school where I had learned the basics of web programming.<br>It had become a hobby where I continued to consolidate my acquired skills, from the creation of static websites to the creation of dynamic websites.</p><p>I started using Linux by joining Epitech. The first Linux system I had installed was Fedora 31.<br>With it, I learned programming in C, in C++, in Python, and of course creating Bash scripts.</p><p>I started to specialized in Linux system administration during my previous work, where I was a DevOps consultant.<br>I had the opportunity to take an on-site training course covering the basics and advanced notions, and I felt in my element.<br>Following this training, to confirm my Linux system administration skills, I decided to take the <a href=\"https://training.linuxfoundation.org/certification/linux-foundation-certified-sysadmin-lfcs/\"> LFCS <\/a> certification which I obtained with <a href=\"https://ti-user-certificates.s3.amazonaws.com/e0df7fbf-a057-42af-8a1f-590912be5460/53be41b8-832e-4e79-a468-64e10b056c27-maximilien-nadji-d2b2531b-484a-44d6-87c5-4fcdd2eddc79-certificate.pdf\"> success <\/a>.</p><p>I dedicated my spare time to continuous learning, keeping my skills sharp and striving toward Linux mastery.</p>"
    },
    "blog_index": {
        "brr": "Backup, Restore and Recovery on Linux",
        "usb": "How to Create a Bootable USB on Linux?",
        "linux": "What is Linux?",
        "git": "Git : A Powerful Tool for Version Control and Collaboration",
        "user_group_file_permissions": "User, Group & File Permissions Management on Linux"
    },
    "linux_article": {
        "title": "What is Linux?",
        "content": "<p>Linux is not an operating system but a kernel, a set of softwares being the main layer between the machine and the operating system.<br>The kernel will be responsible for the following tasks: </p><ul class= \"disc-list\"><li> Managing the machine's memory </li> <li> Managing devices (keyboards, mouses, screens, hard disks) </li> <li> Handling processes corresponding to commands currently running on the system </li> <li> And much more! </li></ul> <br> <img class=\"schema\" src=\"../../static/images/kernel.svg\"><br><br><h2>What is a Linux system, then?</h2><p>A Linux system (called Linux distribution) will therefore correspond to an operating system based on the Linux kernel but with additional components such as: </p><ul class=\"disc-list\"><li> A packet manager (APT, DNF) to install, update or delete softwares </li> <li> A graphical environment (GNOME, KDE) </li> <li> A terminal command shell (Bash, Zsh) </li> <li> And more ! </li></ul> <br> <img class=\"schema\" src=\"../../static/images/linux-system.svg\"><h2>Conclusion</h2><p>The key difference is that Linux is just the kernel, while a Linux System includes everything needed for a fully functioning operating system.<br>A Linux System is what users typically interact with, whereas Linux alone cannot be used directly by end-users without additional software.</p>"
    },
    "usb_article": {
        "title": "How to Create a Bootable USB on Linux?",
        "content": "<p>A bootable USB is a USB drive that contains an operating system (OS) or utility that you can boot your computer from.<br>This can be used to install an OS, run recovery tools, or try out a Linux distribution without installing it on your computer.<br><br>A Live USB is a subset of a bootable USB where the OS runs directly from the USB without being installed on the computer's hard drive.<br><br>On this article, you are going to explore three different methods for creating a bootable USB on Linux.<br>Each method has its own benefits and use cases, so read on to find the best approach for your needs !</p><br><h3>Method 1 : <code>dd</code> (Command-Line Method)</h3><p><code>dd</code> is a powerful, built-in command-line tool available in most Linux distributions.<br>It can be used to create a bootable USB by copying the ISO file of an operating system directly to the USB drive.<br>While it's quick and efficient, caution is needed, as the <code>dd</code> command can easily overwrite data if the wrong device is selected.</p><h4>Steps:</h4><ul class=\"disc-list\"><li><strong>Identify your USB drive:</strong> Run the following command to list your devices: <pre><code><span>$ lsblk</span></code></pre></li><li><strong>Unmount the USB drive (if necessary):</strong> <pre><code><span>$ sudo umount /dev/sdX1 # Replace /dev/sdX1 with the correct USB partition</span></code></pre></li><li><strong>Run the <code>dd</code> command:</strong> Replace <code>/path/to/your.iso</code> with the path to your ISO and <code>/dev/sdX</code> with the correct device path for your USB: <pre><code><span>$ sudo dd if=/path/to/your.iso of=/dev/sdX bs=4M status=progress oflag=sync</span></code></pre></li><li><strong>Eject the USB drive:</strong> <pre><code><span>$ sudo eject /dev/sdX</span></code></pre></li></ul><h4>Pros:</h4><ul class=\"disc-list\"><li>No additional software required.</li><li>Flexible and fast.</li></ul><h4>Cons:</h4><ul class=\"disc-list\"><li>Risk of overwriting data if the wrong device is selected.</li><li>Command-line only, no graphical interface.</li></ul><br><h3>Method 2 : balenaEtcher (Graphical Interface)</h3><p><a href=\"https://etcher.balena.io/\">balenaEtcher</a> is a popular, easy-to-use tool with a graphical interface.<br>It's perfect for beginners or those who prefer not to use the terminal.<br>balenaEtcher simplifies the process of creating a bootable USB and ensures that the process is safe by verifying the image.</p><h4>Steps:</h4><ul class=\"disc-list\"><li><strong>Download and Install balenaEtcher:</strong> Go to the <a href=\"https://etcher.balena.io/\">balenaEtcher website</a> and download appropriate version for your Linux distribution.</li><li><strong>Launch balenaEtcher:</strong> Open the application after installation.</li><li><strong>Select the ISO file:</strong> Click on the \"Flash from file\" button and choose your ISO file.</li><li><strong>Select your USB drive:</strong> Ensure that the correct USB device is selected.</li><li><strong>Click on \"Flash!\":</strong> balenaEtcher will now create the bootable USB drive.</li></ul><h4>Pros:</h4><ul class=\"disc-list\"><li>User-friendly and visually intuitive.</li><li>Cross-platform (works on Linux, MacOS and Windows).</li><li>Verifies the flash process for errors.</li></ul><h4>Cons:</h4><ul class=\"disc-list\"><li>Requires installation.</li><li>Slower than <code>dd</code>.</li></ul><br><h3>Method 3: Ventoy (Multi-ISO USB Tool)</h3><p><a href=\"https://www.ventoy.net/en/index.html\">Ventoy</a> is a powerfull tool that allows you to create a bootable USB drive with multiple operating systems.<br>Instead of writing an ISO directly to the USB, Ventoy installs a bootloader on the USB.<br>You can then drag and drop as many ISO files as you like onto the drive, and choose which one to boot from when you start up your computer.</p><h4>Steps:</h4><ul class=\"disc-list\"><li><strong>Download and Install Ventoy:</strong> Go to the <a href=\"https://www.ventoy.net/en/index.html\">Ventoy website</a> and download the Linux version of Ventoy.</li><li><strong>Install Ventoy to your USB drive:</strong> Extract the files and run the following command to install Ventoy onto the USB drive: <pre><code><span>$ sudo ./Ventoy2Disk.sh -i /dev/sdX</span></code></pre></li><li><strong>Copy ISO files to the USB drive:</strong> Simply drag and drop your ISO files onto the USB.</li><li><strong>Boot from the USB:</strong> When you reboot, Ventoy will display a boot menu, allowing you to choose which ISO to boot.</li></ul><h4>Pros:</h4><ul class=\"disc-list\"><li>Allows multiple ISOs on one USB drive.</li><li>No need to reformat the USB for each new ISO.</li><li>Can be used for testing or running multiple OSes.</li></ul><h4>Cons:</h4><ul class=\"disc-list\"><li>Requires some initial setup.</li><li>May be overkill if you only need a single OS on the USB.</li></ul><br><h3>Which Method Should You Choose?</h3><p>Each method has its own strengths, and the best choice depends on your needs:</p><ul class=\"disc-list\"><li>Use <code>dd</code> if you prefer a command-line approach and need a fast, no-frills solution.</li><li>Use balenaEtcher if you want an easy-to-use graphical tool with built-in error checking.</li><li>Use Ventoy if you want the flexibility to have multiple ISOs on a single USB and need a bootable USB that can serve multiple purposes.</li></ul><h2>Conclusion</h2><p>Creating a bootable USB on Linux can be done in several ways, each offering its own set of advantages.<br>Whether you’re installing a new OS, running recovery tools, or testing out a distro, these three methods provide you with all the options you need.</p>"
    },
    "brr_article": {
        "title": "Backup, Restore and Recovery on Linux",
        "content": "<p>Data is one of the most valuable assets for individuals and businesses alike.<br>Losing critical data due to system failures, cyberattacks, or accidental deletions can have severe consequences.<br>That’s why understanding the processes of backup, restore, and recovery is crucial for safeguarding data and ensuring business continuity.<br>While these terms are often used interchangeably, they serve distinct purposes in data management.<br>In this article, you are going to explore the differences between these three processes and why each one is essential.</p><h2>Backup : The First Line Of Defense</h2><p>Backup is the process of creating copies of data to protect against loss or corruption.<br>Backups ensure that, in the event of an issue, you have an accessible copy of your data stored safely.<br><br>Two examples of how to create a backup without and with encryption:</p><pre><code><span>$ tar -czvf my_backup_$(date +%F_%H-%M-%S) /home/user/documents</span><br><span>$ tar -czvf - /home/user/documents | gpg --symmetric --cipher-algo AES256 -o my_backup_$(date +%F_%H-%M-%S).tar.gz.gpg</span></code></pre><h2>Restore: Bringing Back Lost Data</h2><p>Restoring is the process of retrieving backup data and making it available for use again.<br>It is the action taken when data has been lost, corrupted, or accidentally deleted.<br><br>If you want to decrypt and extract your previous backup, here's how to do it: </p><pre><code><span>$ gpg --output backup_2025-02-18_15-45-00.tar.gz --decrypt backup_2025-02-18_15-45-00.tar.gz.gpg</span><br><span>$ tar -xzvf backup_2025-02-18_15-45-00.tar.gz</span></code></pre><h2>Recovery: Restoring Systems to Normal Operations</h2><p>Recovery goes beyond restoring files; it involves getting an entire system or environment back to operational status after a major failure, such as a cyberattack, hardware failure, or disaster.<br><br> Let's assume your system has crashed, and you have a backup of your entire system called <code>full_system_backup_2025-02-18_10-30-25.tar.gz.gpg</code> located on an external media <code>/mnt/backup</code>.<br>Here's how to do it step by step:</p><br><h3>Step 1 : Boot from Live CD/USB</h3><p>You need to boot into a Linux live environment because it lets you mount your disk without it being in use, ensuring a clean recovery without conflicts.<br><a href=\"/blog/bootable-usb\"> Here's how to create a Linux live USB</a></p><br><h3>Step 2 : Mount the Filesystems</h3><p>Once booted, you open a terminal and you mount the partitions of the target system (where you want to recover the backup to).<br><p>The <code>lsblk</code> command will help you find the disk where Linux was installed (we will assume that your root filesystem is <code>/dev/sda1</code>): </p><pre><code>$ sudo mount /dev/sda1 /mnt</code></pre><p>If <code>/home</code>, <code>/boot</code> partitions exist, mount them too: </p><pre><code><span>$ sudo mkdir -p /mnt/home && sudo mount /dev/sda2 /mnt/home</span><br><span>$ sudo mkdir -p /mnt/boot && sudo mount /dev/sda3 /mnt/boot</span></code></pre><p>You need to mount your Live CD/USB to make accessible your backup file: </p><pre><code><span>$ sudo mount /dev/sdb1 /mnt/backup # Replace /dev/sdb1 with the correct CD/USB partition</span></code></pre><br><h3>Step 3 : Decrypt the Backup (If Encrypted)</h3><p>Remember, in your case, your backup <code>full_system_backup_2025-02-18_10-30-25.tar.gz.gpg</code> is encrypted.<br>Here's how to decrypt it: </p><pre><code><span>$ gpg --output /mnt/backup/full_system_backup_2025-02-18_10-30-25.tar.gz --decrypt /mnt/backup/full_system_backup_2025-02-18_10-30-25.tar.gz.gpg</span></code></pre>You will be prompted for the passphrase used to encrypt the backup.</p><br><h3>Step 4 : Restore the System Backup</h3><p>Once the backup is decrypted (or if it's already in .tar.gz format), you can restore it using <code>tar</code>.<br>Use <code>tar</code> with the <code>--exclude</code> option to avoid overwriting your current mount points like <code>/mnt</code>,<code>/proc</code>,<code>/sys</code>, or <code>/dev</code>.<br>Here's how to do it: </p><pre><code><span>$ sudo tar -xzpf /mnt/backup/full_system_backup_2025-02-18_10-30-25.tar.gz -C /mnt --exclude=/mnt --exclude=/proc --exclude=/sys --exclude=/dev</span></code></pre><h4>Explanation:</h4><ul class=\"disc-list\"><li><code>-x</code> - Extract files.</li><li><code>-z</code> - Uncompress the <code>.tar.gz</code> file.</li><li><code>-p</code> - Preserve permissions.</li><li><code>-f /mnt/backup/full_system_backup_2025-02-18_10-30-25.tar.gz</code> - The backup file to restore from.</li><li><code>-C /mnt</code> - This specifies the target directory (the root of your system, mounted at /mnt).</li><li><code>--exclude=/mnt --exclude=/proc --exclude=/sys --exclude=/dev</code> - Prevents overwriting system directories or special files that should not be restored from the backup.</li></ul><br><h3>Step 5 : Restore Bootloader (if necessary)</h3><p>If you restored the system to a new disk, you may need to restore the bootloader (GRUB) to make the system bootable.<br>Here's how to reinstall GRUB (assuming the root partition is still <code>/dev/sda1</code>): </p><pre><code><span>$ sudo mount --bind /dev /mnt/dev</span><br><span>$ sudo mount --bind /proc /mnt/proc</span><br><span>$ sudo mount --bind /sys /mnt/sys</span><br><span>$ sudo chroot /mnt</span><br><span>$ grub-install /dev/sda # Install GRUB to the MBR of the disk</span><br><span>$ update-grub # Update GRUB's bootloader configuration</span><br><span>$ exit</span></code></pre><br><h3>Step 6 : Reboot the System</h3><p>After recovering the system and installing the bootloader, you should be able to reboot into your recovered system.<br>First, you unmount all the partitions: </p><pre><code><span>$ sudo umount /mnt/boot /mnt/home /mnt/dev /mnt/proc /mnt/sys /mnt/backup /mnt</span></code></pre><p>Then you eject the Live CD/USB: </p><pre><code><span>$ sudo eject /dev/sdb # Replace with the correct CD/USB device</span></code></pre><p>Now, you remove physically the live CD/USB and you reboot the system: </p><pre><code><span>$ sudo reboot</span></code></pre><br><h3>Step 7 : Verify Recovery</h3><p>After rebooting, you can check if everything is restored:</p> <pre><code><span>$ ls /home</span><br><span>$ df -h</span></code></pre><p>Congratulations! You have successfully recovered your Linux system !</p><h2>Conclusion</h2><p>Understanding the distinctions between backup, restore, and recovery helps organizations implement effective data protection strategies.<br>By ensuring that backups are reliable, restores are tested, and recovery plans are in place, businesses can minimize downtime and data loss in the face of unexpected disruptions.</p>",
        "conclusion": "<p>Does your business have a solid backup, restore, and recovery strategy?<br>If not, let's discuss it to implement one !</p>"
    },
    "user_group_file_permissions_article": {
        "title": "User, Group & File Permissions Management on Linux",
        "content": "<p>In any Linux system, whether it's a server, desktop or virtual machine, managing users and groups is essential for ensuring system security, organization, and control.<br>By default, every Linux system operates under a multi-user paradigm, which means different people or services can access the system at the same time.<br>To maintain system integrity, Linux uses user and group management mechanisms that help assign permissions, track access, and organize users in a way that makes it easier to handle large systems efficiently.</p><p>On this article, you will walk through the core concepts and pratical steps involved in user and group management on Linux systems.<br>You will look at how to create and modify users and groups, assign permissions, and follow best practices to maintain a secure and well-organized system.</p><h2>Understanding Linux Users and Groups</h2><h3>What are users in Linux?</h3><p>In Linux, a user refers to any account that can perform operations.<br>Every user is uniquely identified by a <strong>User ID (UID)</strong>, which is a numerical value that the system uses to reference that user.<br>The main purpose of users is to segregate access rights and permissions.<br>There are two main types of users:</p><ul class=\"disc-list\"><li><strong>System users</strong>: These are special accounts created by the system to run services or manage system tasks (<code>root</code>, <code>www-data</code>, <code>sys</code>, etc.)<br>System users typically don't have login access but can own files or execute background processes.</li><li><strong>Regular users</strong>: These are the typical users of the system who have login access, a home directory and the ability to create files and run programs.</li></ul><p>In most Linux distributions, when a user is created, they're given a home directory (like <code>/home/newuser</code>) and a default shell (like <code>/bin/bash</code>).</p><br><h3>What are groups in Linux?</h3><p>A group in Linux is a collection of users.<br>Groups are used to organize users in a way that simplifies permission management.<br>Each user can belong to one or more groups, and every file or resource on a Linux system is assigned a group and an owner.<br>When managing file permissions, it becomes easy to grant a set of users (those in a group) access to certain files without specifying each user individually.<br>There are two categories of groups:</p><ul class=\"disc-list\"><li><strong>Primary group</strong>: Every user belongs to one primary group.<br>This group is usually created when the user is created and, unless specified, typically shares the same name as the user (a user <code>alice</code> will have a primary group named <code>alice</code>).</li><li><strong>Secondary groups</strong>: A user can belong to multiple additional groups giving the user additional permissions for specific resources or tasks.</li></ul><p>For example, a user might be part of a <code>developers</code>group that allows them access to a particular directory or set of files.<br>This makes managing access more efficient than dealing with individual permissions for each user.</p><br><h3>Understanding User and Group IDs</h3><p>I explained earlier, that each user is uniquely identified by a numeric identifier <strong>(UID)</strong>.<br>The same applies to groups <strong>(GID)</strong>.<br>Here's how it works:</p><ul class=\"disc-list\"><li><strong> User ID (UID)</strong>: A unique identifier assigned to each user.<br>The <code>root</code> user has UID 0, and regular users usually start from UID 1000 onward.</li><li><strong>Group ID (GID)</strong>: Similarly, every group has a unique identifier.<br>A user's primary group also has its own GID.</li></ul><p>The mapping between users, groups, and UIDs/GIDs is stored in the <code>/etc/passwd</code> file for users and the <code>/etc/group</code> file for groups.</p><h2>Managing File Permissions</h2><h3>Understanding File Permissions</h3><p>In Linux, file permissions determine who can access and modify files or directories.<br>Permissions are granted based on the owner of the file, the group associated with the file, and others (everyone else).<br>These permissions are represented in three basic types:</p><ul class=\"disc-list\"><li><strong>Read (r)</strong>: Grants the ability to view the contents of a file or list the contents of a directory.</li><li><strong>Write (w)</strong>: Grants the ability to modify or delete a file, or add/delete files from a directory.</li><li><strong>Execute (x)</strong>: Grants the ability to run a file as a program (for executables) or enter a directory (for directories).</li></ul><br><h3>File Permission Format</h3><p>When you view a file's permissions using the <code>ls -l</code> command, the output will start with something like this:</p><pre><code><span>-rwxr-xr-xx</span></code></pre><p>The permissions string is made up of 10 characters:</p><ul class=\"disc-list\"><li>The first character represents the file type. (the most commons are <code>-</code> for regular file, <code>d</code>for directories</code> and <code>l</code> for a symbolic link).</li><li>The next three characters represent the owner's permissions (read, write and execute).</li><li>The following three characters represent the group's permissions.</li><li>The final three characters represent others permissions.</li></ul><p>For example:</p><pre><code><span>-rwxr-xr-- 1 alice developers 1048576 Mar 24 12:00 file.txt</span></code></pre><p>This means:</p><ul class=\"disc-list\"><li><code>rwx</code> (owner permissions): The owner (<code>alice</code>) can read, write, and execute the file.</li><li><code>r-x</code> (group permissions): Members of the <code>developers</code> group can read and execute the file, but they can't modify it.</li><li><code>r--</code> (others permissions): Everyone else can only read the file.</li></ul><br><h3>Understanding Special Permissions</h3><p>Besides the standard read, write, and execute permissions, Linux also includes special permissions that control additional behaviors.<br>These include:</p><ul class=\"disc-list\"><li><strong>Setuid (s)</strong>: When set on an executable file, it allows the program to run with the privileges of the file's owner, typically used for programs that need root privileges (<code>/bin/passwd</code>).<br>Example of <code>setuid</code>:<pre><code><span>-rwsr-xr-x 1 root root 12345 Mar 24 12:00 /usr/bin/passwd</span></code></pre></li><li><strong>Setgid (s)</strong>: When set on a directory, it ensures that files created within the directory inherit the group of the directory rather than the user's primary group.<br>Example of <code>setgid</code> on a directory:<pre><code><span>drwxr-sr-x 2 root staff 4096 Mar 24 12:00 /data/</span></code></pre></li><li><strong>Sticky bit (t)</strong>: Typically used on directories, the sticky bit ensures that only the file's owner or the root user can delete or rename files within that directory, even if others have write access.<br>Commonly used on the <code>/tmp</code> directory.<br>Example of sticky bit:<pre><code><span>drwxrwxrwt 2 root root 4096 Mar 24 12:00 /tmp/</span></code></pre></li></ul><h2>In Practice</h2><h3>Adding Users</h3><p>To add a new user to the system, you can use the <code>useradd</code> command.<br>Here's the basic syntax:</p><pre><code><span>$ sudo useradd bob</span></code></pre><p>This creates a new user with the default settings, which typically includes:</p><ul class=\"disc-list\"><li>A home directory (<code>/home/john</code>)</li><li>A shell (usually <code>/bin/bash</code>)</li><li>No password set by default</li></ul><p>You can specify additional options when creating a user:</p><ul class=\"disc-list\"><li><code>-m</code>: Create the user's home directory.</li><li><code>-s</code>: Specify the shell (<code>/bin/bash</code>, <code>/bin/zsh</code>).</li><li><code>-G</code>: Add the user to one or more groups.</li></ul><pre><code><span>$ sudo useradd -m -s /bin/bash bob</span></code></pre><br><h3>Setting a Password for a User</h3><p>After adding a user, you should set a password.<br>Use the <code>passwd</code> command to do so:</p><pre><code><span>$ sudo passwd bob</span></code></pre><p>This command will prompt you to enter a new password for the user.</p><br><h3>Modifying Users</h3><p>You can modify existing users with the <code>usermod</code> command.<br>Here are some common options:</p><ul class=\"disc-list\"><li><code>-aG</code>: Add a user to an additional group (without removing them from other groups).</li><li><code>-s</code>: Change the user's shell.</li><li><code>-d</code>: Change the user's home directory</li></ul><pre><code><span>$ sudo usermod -aG developers bob</span></code></pre><br><h3>Deleting Users</h3><p>To delete a user, you can use the <code>userdel</code> command.<br>If you want to remove the user's home directory along with their account, use the <code>-r</code> option:</p><pre><code><span>$ sudo userdel -r bob</span></code></pre><br><h3>Adding Groups</h3><p>You can create a new group using the <code>groupadd</code> command:</p><pre><code><span>$ sudo groupadd admins</span></code></pre><br><h3>Modifying Groups</h3><p>To modify an existing group, use the <code>groupmod</code> command.<br>You can change the group name with the <code>-n</code> or change the group ID (GID) with the <code>-g</code>option.</p><pre><code><span>$ sudo groupmod -n developers devs</span><br><span>$ sudo groupmod -g 1010 devs </span></code></pre><br><h3>Deleting Groups</h3><p>To remove a group, use the <code>groupdel</code> command:</p><pre><code><span>$ sudo groupdel devs</span></code></pre><br><h3>Changing File Permissions with <code>chmod</code></h3><p>The <code>chmod</code> command allows you to change file or directory permissions.<br>You can use symbolic or numeric modes.</p><ul class=\"disc-list\"><li><strong>Symbolic Mode</strong>: Adds <code>(+)</code>, removes <code>(-)</code>, or sets <code>(+)</code> permissions for the user, group, or others:</p><pre><code><span>$ chmod u+x file.txt # Give execute permission to the owner of file.txt</span><br><span>$ chmod g-w file.txt # Remove write permission for the group on file.txt</span><br><span>$ chmod o=r file.txt # Set read-only permissions for others on file.txt</span></pre></code></li><li><strong>Numeric Mode</strong>: Uses numbers to define permissions, where:<ul class=\"disc-list\"><li><strong>4</strong>: Read</li><li><strong>2</strong>: Write</li><li><strong>1</strong>: Execute</li><li><strong>0</strong>: No permission</li></ul><br>You can add up the values to set the permissions for owner, group, and others.<br>For example, <code>7</code> (read + write + execute) for the owner, <code>5</code> (read + execute) for the group, and <code>5</code> (read + execute) for others:<pre><code><span>$ chmod 755 file.txt</span></code></pre></li></ul><br><h3>Changing File Owner and Group with <code>chown</code></h3><p>The <code>chown</code> command allows you to change the owner and group of a file or directory.<br>The basic syntax is:</p><pre><code></span>$ sudo chown owner:group filename</span></code></pre><p>Examples:</p><pre><code><span>$ sudo chown alice:developers file.txt # Change the owner of file.txt to alice and the group to developers</span><br><span>$ sudo chown alice file.txt # Change the owner of file.txt to alice but leave the group unchanged</span><br><span>$ sudo chown :admins file.txt # Change the group of file.txt to admins but leave the owner unchanged</span></code></pre><br><h3>Changing Group Ownership with <code>chgrp</code></h3><p>The <code>chgrp</code> command allows you to change the group of a file or directory.<br>The syntax is:</p><pre><code><span>$ sudo chgrp groupname filename</span></code></pre><p>Example:</p><pre><code><span>$ sudo chrgp staff file.txt</span></code></pre><br><h3>Best Practices for Managing Users, Groups, and Permissions</h3><ul class=\"disc-list\"><li><strong>Least Privilege Principle</strong>: Always grant the minimum necessary permissions to users and groups.<br>Don't give users write or execute permissions unless absolutely needed.</li><li><strong>Use Groups Effectively</strong>: Group users by role (<code>admins</code>, <code>developers</code>, <code>users</code>) and assign permissions to groups instead of individual users.<br>This simplifies permission management.</li><li><strong>Regular Audits</strong>: Periodically review user accounts, group memberships, and file permissions to ensure that no unnecessary access is granted.<br>This helps improve security</li><li><strong>Use <code>sudo</code> for Elevated Privileges</strong>: Avoid giving users direct root access.<br>Instead, configure <code>sudo</code> to grant temporary elevated privileges when needed.</li></ul><h2>Conclusion</h2><p>Managing users, groups, and file permissions is fundamental to ensuring that your Linux system remains organized and secure.<br>By using commands like <code>useradd</code>, <code>usermod</code>, <code>userdel</code>, <code>chmod</code>, <code>chown</code>, and <code>chgrp</code>, you can easily control who has access to what on your system.<br>Always follow best practices for security and regularly review your configurations to ensure that the principle of least privilege is maintained.</p>"
    },
    "git_article": {
        "title": "Git : A Powerful Tool for Version Control and Collaboration",
        "content": "<p>In the fast-paced world of software development, where multiple people collaborate on a single project, managing changes, tracking progress, and resolving conflicts can quickly become a challenge.<br>This is where <strong>Git</strong>, a distributed version control system, steps in to make the process more manageable.</p><p>In this article, we will dive into what Git is, its importance in the software development lifecycle, and highlight some useful Git commands.</p><br><h3>What is Git?</h3><p>Git is a version control system (VCS) that helps developers track changes to files, primarly source code, over time.<br>It enables multiple developers to work on the same project simultaneously without overwriting each other's work.<br>The primary functions of Git revolve around tracking changes, enabling collaboration, managing different versions of a project, and simplifying the process of undoing or reverting to previous versions when necessary.</p><br><h3>Installing Git</h3><p>Git is available in most Linux distributions' package managers.<br>Below are the installation steps for the most common Linux distributions:</p><ul class=\"disc-list\"><li><strong>Installing Git on Ubuntu/Debian-based Distributions</strong><ul class=\"disc-list\"><li><strong>Update your package list</strong>: Open a terminal and run the following command to ensure your package list is up to date:<pre><code><span>$ sudo apt update</span></code></pre></li><li><strong>Install Git</strong>: Once the package list is updated, you can install Git using the <code>apt</code> package manager:<pre><code><span>$ sudo apt install git</span></code></pre></li><li><strong>Verify the installation</strong>: After installation is complete, verify that Git is correctly installed by checking the version: <pre><code><span>$ git --version</span></code></pre></li></ul><li><strong>Installing Git on Fedora</strong><ul class=\"disc-list\"><li><strong>Update the package list</strong>: First, update your system's package database: <pre><code><span>$ sudo dnf check-update</span></code></pre></li><li><strong>Install Git</strong>: Now, install Git using the <code>dnf</code> package manager: <pre><code><span>$ sudo dnf install git</span></code></pre></li><li><strong>Verify the installation</strong>: Confirm the installation by checking the version: <pre><code><span>$ git --version</span></code></pre></li></ul></li></ul><br><h3>Configuring Git</h3><p>Once Git is installed, it's a good idea to configure your basic Git settings, such as your name and email, which will be attached to your commits (I explain commits in more detail further down):</p><ul class=\"disc-list\"><li><strong>Set your username</strong>: <pre><code><span>$ git config --global user.name \"Your Name\"</span></code></pre></li><li><strong>Set your email</strong>:<pre><code><span>$ git config --global user.email \"your.email@example.com\"</span></code></pre><p>These settings ensure that each commit you make will be properly attributed to you.</li><br><li><strong>Use Git with SSH</strong>: Setting up <code>SSH</code> for Git is an important step for securely interacting with remote repositories, especially when you are pushing or pulling changes from services (like GitHub).<br>Here's how to configure SSH with Git:<ul class=\"disc-list\"><li><strong>Generate SSH Key Pair</strong>: First, you need to create an SSH key pair (public and private key) if you don't have one already.<br>This allows you to authenticate with Git servers securely without needing to enter your password each time.<br>Run the following command in your terminal to generate a new SSH key:<pre><code><span>$ ssh-keygen -t rsa -b 4096 -C \"your.email@example.com\"</span></code></pre>Explanation: <ul class=\"disc-list\"><li><code>-t rsa</code>: Specifies the type of key (RSA in this case).</li><li><code>-b 4096</code>: Sets the number of bits in the key (4096 is recommended for stronger encryption).</li><li><code>-C \"your.email@example.com\"</code>: Adds a label to the key for identification (your email).</li></ul><br>You'll be prompted to save the key pair to a specific location.<br>The default location is usually fine (it will save to <code>~/.ssh/id_rsa</code>), so you can press <strong>Enter</strong> to accept it.<br>A passphrase will be asked.<br>You can set one for extra security, or leave it empty for no passphrase by pressing <strong>Enter</strong>.</li><br><li><strong>Add SSH Key to SSH Agent</strong>: Once you have generated your SSH key, you will need to add it to the SSH agent so that it can be used to authenticate your connection.<br>Start the SSH agent by running:<pre><code><span>$ eval \"$(ssh-agent -s)\"</span></code></pre>Then, add your SSH private key to the agent:<pre><code><span>$ ssh-add ~/.ssh/id_rsa</span></code></pre>This will output your public key.<br>Copy everything from <code>ssh-rsa</code>to your email.<br>Now, go to your Git hosting service (GitHub, or Gitlab), and add this key to your account.<br><br><strong>For GitHub</strong>:<ul class=\"disc-list\"><li>Click on your profile picture at the top right -> Settings -> SSH and GPG Keys</li><li>Click <strong>New SSH Key</strong>, then paste the copied key into the key field.</li><li>Save the key.</li></ul><br><strong>For Gitlab</strong>:<ul class=\"disc-list\"><li>Click on your profile picture at the top left -> Preferences -> SSH Keys</li><li>Click <code>Add new key</code>, then paste your public key and give it a title.<br>You can optionally set an expiration date or leave it empty if you want your key to become always valid.</li><li>Save the key.</li></ul><br><li><strong>Test SSH Connection</strong>: After you have added your SSH key to your Git hosting service, test the SSH connection to make sure everything is set up correctly:<pre><code><span>$ ssh -T git@github.com # Example with GitHub</span><br><span>$ ssh -T git@gitlab.com # Example for GitLab</span></code></pre>If everything is configured properly, you should see something like:<pre><code><span>$ Hi username! You've been successfully authenticated, but GitHub does not provide shell access.</span><br><span>$ Welcome to Gitlab, @username!</span></code></pre></li></ul><br><h3>Context of Git in Action</h3><p>Imagine you are part of a software development team working on a web application.<br>There are front-end and back-end developers, each working on different aspects of the app.<br>You need a system that allows everyone to work on their parts without interfering with one another's code.<br>Additionnally, you want a way to keep a history of all changes, so if a bug appears, you can trace it back and fix it.</p><p>Git provides the framework for developers to collaborate effectively:</p><ul class=\"disc-list\"><li><strong>Tracking changes</strong>: Git records every modification to the codebase, so you can always refer back to previous versions.</li><li><strong>Branching and merging</strong>: Developers can work on seperate branches of the codebase, enabling them to work on different features or bug fixes simultaneously.<br>These branches can later be merged into the main project.</li><li><strong>Collaboration</strong>: Git allows developers to share their changes with others and pull updates from other team members, helping to manage potential conflicts when changes overlap.</li></ul><br><h3>Key Git Concepts</h3><p>Before diving into the practical commands, it's important to understand a few key concepts:</p><ul class=\"disc-list\"><li><strong>Repository</strong>: This is the storage space where your project lives.<br>A Git repository (repo) contains all the project's files and their history. They are two types of repository: <ul class=\"disc-list\"><li><strong>Local Repository</strong>: The repo on your machine.</li><li><strong>Remote Repository</strong>: The central repository (often hosted on platforms like GitHub or GitLab).</li></ul><li><strong>Commit</strong>: A snapshot of changes made to the files in the project.<br>Each commit has a unique ID and includes information like the changes made, the author, and a message describing the change.</li><li><strong>Branch</strong>: A pointer to a specific commit.<br>Branches allow developers to work independently on a feature without affecting the main project.<br>After development, changes can be merged into the main branch (usually called \"main\" or \"master\").</li><li><strong>Merge</strong>: The process of integrating changes from one branch into another.</li></ul><br><h3>Useful Git Commands</h3><p>Here are some essential Git commands that will help you manage your Git repositories:</p><ul class=\"disc-list\"><li><strong>git init</strong>: Initialize a new Git repository.<pre><code><span>$ git init</span></code></pre><p>This command creates a new Git repository in the current directory.<br>It's the first step when you start working on a new project with Git</p></li><br><li><strong>git clone</strong>: Clone a repository from a remote source (like GitHub) to your local machine.<pre><code><span>$ git clone https://github.com/username/repository.git # Clone with HTTPS</span><br><span>$ git clone git@github.com:username/repository.git # Clone with SSH</span></code></pre></li><li><strong>git status</strong>: View the status of your working directory and staging area.<pre><code><span>$ git status</span></code></pre></li><li><strong>git add</strong>: Stage changes to be committed.<pre><code><span>$ git add &lt;file-name&gt; # Add &lt;file-name&gt; to the staging area</span><br><span>$ git add . # Add all changes from the current directory and its subdirectories to the staging area</span></code></pre></li><li><strong>git commit</strong>: Record changes in the repository.<pre><code><span>$ git commit -m \"Commit message\"</span></code></pre></li><li><strong>git pull</strong>: Fetch and merge changes from a remote repository.<pre><code><span>$ git pull origin main</span></code></pre></li><li><strong>git push</strong>: Push your local commits to a remote repository.<pre><code><span>$ git push origin main</span></code></pre></li><li><strong>git branch</strong>: List, create, or delete branches.<pre><code><span>$ git branch # List branches</span><br><span>$ git branch &lt;name&gt; # Create a new branch</span><br><span>$ git branch -d &lt;name&gt; # Delete a branch</span></code></pre></li><li><strong>git checkout</strong>: Switch branches or restore files.<pre><code><span>$ git checkout &lt;branch-name&gt; # Switch branches</span><br><span>$ git checkout -- &lt;file-name&gt; # Restore file</span></code></pre><li><strong>git merge</strong>: Merge changes from one branch into another.<pre><code><span>$ git merge &lt;branch-name&gt;</span></code></pre></li><li><strong>git rebase</strong>: Rebase your branch onto another branch.<pre><code><span>$ git rebase origin/main</span></code></pre><p>Rebase your feature branch onto the latest <code>main</code> to keep your branch up-to-date and avoid unnecessary merge commits.</p></li><br><li><strong>git log</strong>: View the commit history.<pre><code><span>$ git log</span></code></pre></li><li><strong>git reset</strong>: Undo changes.<pre><code><span>$ git reset &lt;commit-id&gt; # Reset to &lt;commit-id&gt;, unstages changes and keeps files in the working directory unchanged</span><br><span>$ git reset --soft &lt;commit-id&gt; # Reset to &lt;commit-id&gt; and keeps changes staged in the staging area, ready to commit again</span><br><span>$ git reset --hard &lt;commit-id&gt; # Reset to &lt;commit-id&gt; and discards all changes in the staging area and working directory</span></code></pre></li></ul><h2>Conclusion</h2><p>Git is an indispensable tool for modern software development.<br>It provides a robust, flexible way to manage code, collaborate with others, and maintain a clean history of changes.<br>By using the commands mentionned above, you can effectively use Git to track, manage, and merge/rebase changes as part of your development workflow.</p><p>As you grow more familiar with Git, you will discover even advanced features like <code>git submodules</code>, <code>git bisect</code> or <code>git cherry-pick</code>, that will streamline your development process even further.<br>But for now, these basic commands will provide a solid foundation to begin collaborating efficiently and managing your codebase with ease.</p>"
    }
}
